package com.zeng.dsa.dongtaiguihua

/**
 *
 * @author zengwang
 * @create 2022-01-31 1:46 下午
 * @desc:
 */
object Leet96 {
  def main(args: Array[String]): Unit = {

  }

  /**
   * 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？
   * 返回满足题意的二叉搜索树的种数。
   *
   * 画图、举例n=1,2,3时的情况、分析：
   * 划分子问题:
   *  比如n=3，则有3个节点，值是1，2，3. 这三个节点轮流当做根节点，则可以将问题分解为
   *  1作为根节点时，对应的搜索二叉树的数量，记做A
   *  2作为根节点时，对应的搜索二叉树的数量，记做B
   *  3作为根节点时，对应的搜索二叉树的数量，记做C
   *  则n=3 对应的搜索二叉树的数量 = A + B + C
   *
   * 求解子问题:
   *  如何分别求A、B、C？ 不同根节点的树布局是不一样的，但是总结起来，
   *  固定根节点，对应的搜索二叉树的数量就是： 左子树的布局数量 * 右子树的布局数量
   *  举例，比如固定根节点 1，然后左子树的情况有: M, N；右子树的情况有: Q, P
   *  则左右子树的情况可以是MQ, MP, NQ, NP组合
   *
   * 1.明确dp数组以及下标的定义
   * dp(i) 代表i个不同节点组成的二叉搜索树布局个数
   * 2.转换方程
   * 对于i个节点，值为 [1, i]，我们轮流取某一个节点做为根节点，统计当前情况下的二叉搜索树数量，一直累加
   * for (j <-  1 to i)
   *  dp(i) += dp(j-1) * dp(i-j)
   * PS:  j-1是当前根节点j的左子树节点个数, i-j是右子树的节点个数
   * 3.初始化
   * dp(0) = 1，这样乘积不至于为0
   * 4.遍历顺序
   * 从前向后，举例n=3，4可以推导出来
   * 在求dp(4)的时候，最多用到dp(3)
   * 5.打印dp
   *
   * dp(3) = dp(0) * dp(2) // 根节点是1
   *  + dp(1) * dp(1) // 根节点是2
   *  + dp(0) * dp(2) // 根节点是1
   *
   */
  def numTrees(n: Int): Int = {
    val dp: Array[Int] = new Array[Int](n + 1)
    dp(0) = 1
    for(i <- 1 to n) { // 求dp(n)前面的状态
      for (j <- 1 to i) { // 对于每一个dp(i)，轮流计算1~i的每个节点做为根节点后，布居数进行累加
        dp(i) += dp(j - 1) * dp(i - j)
      }
    }
    dp(n)
  }
}
